# -*- coding: utf-8 -*-
"""Coding Based Agent

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r4iAqBzJUiiwREzHgW8zpHJ4_O-SN5dj
"""

!pip -q install openai fal-client google-api-python-client \
               google-auth-httplib2 google-auth-oauthlib \
               youtube-uploader-selenium yt-dlp tenacity requests

import os, json, uuid, base64, subprocess, tempfile, pathlib, time
import requests
from datetime import datetime
from google.colab import userdata, files
from google.colab.userdata import SecretNotFoundError
from openai import OpenAI
from fal_client import submit as fal_submit
from tenacity import retry, stop_after_attempt, wait_fixed

# -------- secrets ----------
OPENAI_KEY  = userdata.get('OPENAI_API_KEY')
FAL_KEY     = userdata.get('FAL_KEY')
YOUTUBE_SECRETS = userdata.get('YOUTUBE_UPLOAD_CLIENT_SECRETS')
try:
    REFRESH_TOKEN = userdata.get('YOUTUBE_REFRESH_TOKEN')
except SecretNotFoundError:
    REFRESH_TOKEN = None
assert OPENAI_KEY and FAL_KEY and YOUTUBE_SECRETS, "âŒ  Missing secrets"
os.environ["FAL_KEY"] = FAL_KEY
client = OpenAI(api_key=OPENAI_KEY)

# -------- 1. brainstorm ----------
SYSTEM = """You are a viral TikTok/Shorts writer.
Return ONLY a JSON object with keys:
title, hook, script (â‰ˆ8s read under 30 words), vertical_hashtags (10â€“15 lowercase words/phrases, no symbols)"""

def brainstorm(seed: str = "random brainrot") -> dict:
    return json.loads(
        client.chat.completions.create(
            model="gpt-4o-mini",
            response_format={"type": "json_object"},
            messages=[
                {"role": "system", "content": SYSTEM},
                {"role": "user", "content": f"Topic: {seed}"}
            ]
        ).choices[0].message.content
    )
# -------- 2. TTS (Fal) ----------
def tts(text: str) -> bytes:
    handler = fal_submit("fal-ai/chatterbox/text-to-speech",
                         arguments={"text": text})
    wav_url = handler.get()["audio"]["url"]
    return requests.get(wav_url).content

# ------------------ 3. VIDEO (WaveSpeed + YouTube Data API v3) ----------
WAVESPEED_KEY = userdata.get('WAVESPEED_API_KEY').strip()
WAVESPEED_URL = "https://api.wavespeed.ai/api/v3/bytedance/seedance-v1-lite-t2v-1080p"

def make_video(prompt: str, audio_b64: str) -> str:
    """Returns LOCAL path of silent MP4 (audio merged later)."""
    headers = {"Authorization": f"Bearer {WAVESPEED_KEY}"}

    # 1. create prediction
    job = requests.post(WAVESPEED_URL, headers=headers, timeout=30,
                        json={"prompt": prompt, "aspect_ratio": "9:16",
                              "duration": 8, "camera_fixed": False,
                              "seed": abs(hash(prompt)) % 1_000_000}).json()

    # fix both possible key locations
    pred_id = job.get('id') or job.get('data', {}).get('id')
    if not pred_id:
        raise RuntimeError("WaveSpeed launch failed: " + str(job))

    print(f"ðŸŒŠ  WaveSpeed prediction {pred_id} â€“ waiting 75 secondsâ€¦")
    time.sleep(75)                                        # blind wait

    # 2. download silent MP4
    mp4_url = f"https://d1q70pf5vjeyhc.cloudfront.net/predictions/{pred_id}/1.mp4"
    silent = tempfile.NamedTemporaryFile(suffix=".mp4", delete=False)
    silent.write(requests.get(mp4_url, timeout=60).content)
    silent.close()
    return silent.name          # local file path

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
import json
import os

def upload_youtube(video_path: str, metadata: dict) -> str:
    """Upload to YouTube using a pre-saved refresh token (headless Colab-friendly)."""
    token_path = "/tmp/token.json"
    creds = None

    # Load credentials if token exists
    if os.path.exists(token_path):
        creds = Credentials.from_authorized_user_file(
            token_path,
            scopes=["https://www.googleapis.com/auth/youtube.upload"]
        )

    # Refresh or build credentials from scratch using refresh token
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            if not REFRESH_TOKEN:
                raise ValueError("âŒ YOUTUBE_REFRESH_TOKEN is missing but required for headless upload.")

            # Parse client secrets
            secrets = json.loads(YOUTUBE_SECRETS)
            client_id = secrets["web"]["client_id"]
            client_secret = secrets["web"]["client_secret"]

            creds = Credentials(
                None,
                refresh_token=REFRESH_TOKEN,
                token_uri="https://oauth2.googleapis.com/token",
                client_id=client_id,
                client_secret=client_secret,
                scopes=["https://www.googleapis.com/auth/youtube.upload"]
            )
            creds.refresh(Request())

        # Save refreshed credentials
        with open(token_path, "w") as token:
            token.write(creds.to_json())

    # Build YouTube client
    youtube = build("youtube", "v3", credentials=creds)

    # Prepare metadata
    body = {
        "snippet": {
            "title": metadata["title"],
            "description": metadata["description"],
            "tags": metadata.get("keywords", "").split(",") if metadata.get("keywords") else [],
            "categoryId": "22"
        },
        "status": {
            "privacyStatus": "public"
        }
    }

    media = MediaFileUpload(video_path, chunksize=-1, resumable=True)
    request = youtube.videos().insert(part="snippet,status", body=body, media_body=media)

    print("ðŸ“¤ Uploading to YouTube...")
    response = None
    while response is None:
        status, response = request.next_chunk()
        if status:
            print(f"âœ… {int(status.progress() * 100)}%")

    print(f"âœ… YouTube video ID: {response['id']}")
    return response["id"]
# -------- 5. glue (quota-safe) ----------
def run_agent(seed: str = "cat brainrot") -> str:
    print("ðŸ§   Brainstormingâ€¦")
    idea   = brainstorm(seed)
    print("ðŸ“œ  Script:", idea["script"])
    print("ðŸ”‰  TTSâ€¦")
    audio_bytes = tts(idea["script"])
    audio_b64   = base64.b64encode(audio_bytes).decode()
    print("ðŸŽ¬  Generating videoâ€¦")
    silent_path = make_video(idea["hook"], audio_b64)   # silent MP4

    # ---- mux audio ----
    audio_path = tempfile.NamedTemporaryFile(suffix=".wav", delete=False)
    audio_path.write(audio_bytes); audio_path.close()

    final_path = tempfile.NamedTemporaryFile(suffix=".mp4", delete=False).name
    subprocess.run([
        "ffmpeg", "-y", "-i", silent_path, "-i", audio_path.name,
        "-c:v", "copy", "-c:a", "aac", "-shortest", final_path
    ], check=True, capture_output=True)

    # ---- ALWAYS give user the file FIRST ----
    print("ðŸ’¾  Local copy ready â†’ downloadingâ€¦")
    files.download(final_path)          # <â€” ALWAYS happens

    # ---- upload with safety net ----
    meta = {
        "title": idea["title"] + " #Shorts",
        "description": idea["script"] + "\n" +
                      " ".join("#" + h for h in idea["vertical_hashtags"]),
        "thumbnail": ""
    }

    try:
        print("ðŸ“¤  Uploading to YouTubeâ€¦")
        video_id = upload_youtube(final_path, meta)
        print("âœ…  YouTube video ID:", video_id)
    except Exception as e:
        # catch quota, network, strikes, etc.
        print("âš ï¸  Upload failed:", str(e))
        print("â„¹ï¸  Video is still saved locally (see download above).")

    return final_path

# -------- 6. kick-off ----------
if __name__ == "__main__":
    outfile = run_agent("cat brainrot")
    files.download(outfile)